\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 1: Stromrallye} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeilnahmeId}{52586}       % Teilnahme-Id angeben
\newcommand{\Namen}{Michal Boron} % Namen der Bearbeiter/-innen dieser Aufgabe angeben
 
% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Teilnahme-Id: \TeilnahmeId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}
\usepackage{seqsplit}
\usepackage{verbatim}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cite}

\usepackage{hyperref}
\hypersetup{
    colorlinks=false,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
% Für Bilder
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage{svg}
\graphicspath{ {./images/} }

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{gensymb}
\usepackage{tikz}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  keywordstyle=\color{blue},commentstyle=\color{mygreen},
  stringstyle=\color{mymauve},rulecolor=\color{black},
  basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
  captionpos=b, % sets the caption-position to bottom
  keepspaces=true, % keeps spaces in text
  numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
  showtabs=false, stepnumber=2, tabsize=2, title=\lstname
}

% Diese beiden Pakete müssen zuletzt geladen werden
%\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}
\newtheorem{lemma}{Beobachtung}
\usepackage[backgroundcolor=lightgray]{todonotes}
\newcommand{\TODO}[1]{\todo[inline]{#1}}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Teilnahme-Id: \LARGE \TeilnahmeId \\\\
	    \LARGE Bearbeiter dieser Aufgabe: \\ 
	    \LARGE \Namen\\\\}
\date{\LARGE April 2020}

\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Lösungsidee}
\subsection{Definitionen}

Als eine \textit{Batterie} bezeichne ich ein Objekt mit zwei Koordinaten $x$, $y$ und einer Ladung $c$.
Unter einer \textit{Ladung} versteht man eine nichtnegative, rationale Zahl.
Bei Koordinaten sowie bei einer Ladung konzentrieren wir uns auf nichtnegative, ganze Zahlen.\\

Gegeben seien eine zweidimensionale, quadratische Matrix $M$ mit der Seitenlänge $l$, eine Menge von Batterien $B$
und eine Startbatterie $s$.\\
Jeweilige Batterie $b_i$ aus der Menge $B$ besitzt zwei Koordinaten $x_i \leqslant l$ und $y_i \leqslant l$ und eine Ladung $c_i$.\\
In der Matrix gibt es \textit{Felder}. Jedes Feld ist eine Kombination aus einer $x$-- und einer $y$--Koordinate.
Das bedeutet, dass jede Batterie auch auf einem Feld liegt.\\

Nach der Aufgabenstellung dürfen wir einen \textit{Schritt} zwischen zwei Feldern machen. Dieser Schritt ist 
ein Übergang von einem Feld zu einem anderen. Nach der Aufgabenstellung dürfen wir Schritte nach links, rechts oben und unten machen.
Angenommen, stehen wir auf einem Feld $f$ mit Koordinaten ($x_f,y_f$). Wir dürfen einen Schritt
\begin{itemize}
\item nach links zum Feld mit einer $x$--Koordinate um 1 kleiner als $x_f$, also zum Feld ($x_{f-1},y_f$),
\item nach rechts zum Feld mit einer $x$--Koordinate um 1 größer als $x_f$, also zum Feld ($x_{f+1},y_f$),
\item nach oben zum Feld mit einer $y$--Koordinate um 1 kleiner als $y_f$, also zum Feld ($x_f,y_{f-1}$),
\item nach unten zum Feld mit einer $y$--Koordinate um 1 größer als $y_f$, also zum Feld ($x_f,y_{f+1}$),
\end{itemize}
machen.

Wir können nun feststellen, dass
\begin{lemma}\label{observ:distances}
die minimale Anzahl der Schritte von einem Feld, auf dem eine Batterie $i$ liegt, zu einem Feld, 
auf dem eine Batterie $j$ liegt, konstant ist.
\end{lemma}

Die minimale Anzahl der Schritte, die man von einem Feld $p$ zu einem Feld $q$ machen muss, nenne
ich die \textit{Entfernung zwischen $p$ und $q$} oder \textit{Entfernung von $p$ zu $q$}.\\

Die Anzahl der Schritte, die wir machen dürfen, ist durch die Größe der Ladung determiniert.
Wir starten auf dem Feld der Startbatterie, auch \textit{Startfeld} genannt.
Laut der Aufgabenstellung nehmen wir die Ladung der Batterie, auf Feld deren, wir momentan stehen und 
die Größe dieser Ladung der Anzahl der Schitte entpricht, die wir momentan machen dürfen. 
Eine solche Ladung bezeichne ich als die \textit{aktuelle Ladung}. Diese Ladung verkleinert sich um 1
mit jedem gemachten Schritt.\\
Wenn die Anzahl der Schritte reicht, um ein anderes Feld mit einer Batterie zu erreichen, müssen wir
unsere aktuelle Ladung $a$ sofort gegen die auf dem Feld liegenden Ladung $b$ austauschen. Dann lassen
wir die Ladung $a$ auf dem Feld der Ladung $b$ liegen. $b$ wird zu unserer nächsten aktuellen Ladung.\\

Jede Batterie besitzt auch einen \textit{Eingabeindex}, der beim Einlesen zugeordnet ist.
Diese Indizes entsprechen der Reihenfolge der Batterien in der Eingabe. Die Startbatterie besitzt stets den Eingabeindex 0.\\

\subsection{Graph}
Wir ordnen jedem Feld in der Matrix einen \textit{Brettindex} zu.
Wir legen eine neue Menge fest: $V$. In dieser Menge befinden sich alle Brettindizes der Felder in $M$.
Außerdem legen wir eine andere Menge fest: $E$.
Wir iterieren durch alle Felder in $M$. Für jedes Feld $i$ werden die Brettindizes seiner benachbarten Felder bestimmt,
also derjenigen, zu denen man von $i$ einen Schritt machen kann.
In der Menge $E$ wird jeweils die Verbindung zwischen $i$ und einem Nachbarfeld mit Hilfe der Indizes von $i$ 
und dem Nachbarn gespeichert. Jedes Feld kann dementsprechend maximal 4 Nachbarfelder besitzen.\\

Anhand der festgelegten Mengen lässt sich ein ungerichteter, ungewichteter Graph $G(V, E)$ bilden.
In diesem Graphen ist jeder Knoten ein Feld aus der Matrix $M$. Jede Kante ist demzufolge ein
Schritt zwischen zwei Feldern in $M$. Sie hat stets das Gewicht 1.

\subsubsection{BFS}
Anhand der Beobachtung \ref{observ:distances} lässt sich feststellen, dass diese Entfernungen zwischen Feldern,
auf denen Batterien liegen, sich durch einen Lauf vom Breitensuche-Algorithmus 
(engl. \textit{breadth--first serach, BFS}) einfach bestimmen lassen.\\

Für eine Batterie $b$ können wir auf folgender Weise die Entfernungen zu allen anderen Batterien bestimmen.
Sie werden in einer zweidimensionaller Tabelle $A$ gespeichert.
Bei jeder iterierten Stelle $A_{i,j}$ in der Tabelle $A$ entsprechen $i$ der Index der Batterie,
von der die Entfernung gemessen wird, und $j$ der Index der anderen Batterie, deren Entfernung von $i$ bestimmt wird.
Dementsprechend ist $A_{i,j}$ dann die minimale Entfernung von $i$ zu $j$.\\
Es gibt auch eine parallele, zweidimensionale Tabelle $A'$, deren Funktion ich im nächsten Abschnitt erläutere.\\
Wir finden im Graphen $G$ den Knoten, der dem Feld, auf dem $b$ liegt, entspricht.
Wir fügen diesen Knoten mit einer Entfernung 0 in eine Warteschlange ein.
Diese Warteschlange wird iteriert, so lange es noch Knoten gibt.
Jeden iterierten Knoten nennen wir $i$ und seine entsprechende Entfernung von $b$: $d_i$.\\
Wie nehmen $i$ aus der Warteschlange heraus. 
Danach wird durch die Nachbarknoten von $i$ iteriert, dass heißt, durch diejenigen, die eine Kante mit $i$ besitzen.
Jeden iterierten, benachbarten Knoten nenne ich an dieser Stelle $j$.
Es wird überprüft, ob $j$ bereits besucht wurde. Wenn ja, wird der Knoten $j+1$ genommen.
Wenn nicht, dann wird überprüft, ob der Knoten $j$ einem Feld entspricht, auf dem eine Batterie liegt.
Wenn nicht, wird $j$ ganz normal in die Warteschlange mit der Entfernung $d_i + 1$ eingefügt.
$j$ wird auch danach als besucht markiert.\\
Wenn aber der Knoten $j$ einem Feld entspricht, auf dem eine Batterie liegt, wird zuerst geprüft,
ob $A_{i,j}$ bereits gleich 1 oder 2 ist (mehr dazu im nächsten Abschnitt).
Wenn nicht, wird $A_{i,j}$ der Wert $d_i + 1$ zugewiesen. Nun, nur wenn $d_i + 1 > 2$ wird der Knoten $j$ als
besucht gekennzeichnet.\\
Wenn aber $A_{i,j}$ bereits gleich 1 oder 2 ist, wird geprüft, ob $A'_{i,j}$ bereits einen Wert besitzt.
Wenn ja und wenn $d_i + 1 < A'_{i,j}$, wird der Wert $A'_{i,j}$ als $d_i + 1$ aktualisiert. 
Wenn es früher keinen Wert $A'_{i,j}$ nicht gab, wird er als $d_i + 1$ gespeichert.\\

Wir sollen bemerken, dass wir 
\begin{lemma}\label{observ:not-minimal-steps}
auf dem Weg von einer Batterie $p$ zur Batterie $q$ nich immer die minimale Anzahl an Schritten $A_{p,q}$
machen können, wenn die Größe der Ladung genügend ist, um das zu tun.
\end{lemma}
Es ist auch zu bemerken, dass
\begin{lemma}\label{observ:2k-steps}
wenn die minimale Anzahl der Schritte $A_{p,q} > 2$ oder $A'_{p,q} > 2$ ist, kann man stets die Batterie $q$ auch in $A_{p,q}+2k$,
bzw. in $A'_{p,q}+2k$,
wobei $k \in \mathbb{N^{+}}$, Schritten erreichen, so lange die Größe der aktuellen Ladung das erlaubt.
\end{lemma}
Der Beweis der Beobachtung \ref{observ:2k-steps} ist trivial: wenn wir auf einem Feld $f$ stehen, können nach demselben
Feld $f$ mit genau 2 Schritten zurückehren, wenn wir zu einem benahcbarten Feld $h$ einen Schritt machen 
und dann von $h$ zu $f$ zurück.\\
So kann man auch die Beobachtung \ref{observ:not-minimal-steps} beweisen, indem man bemerkt, dass wir
auf dem Weg von $p$ zu $q$ einfach einen Schritt zurück und nach vorne machen.\\

Genau aus dem Grund musste ich auch zusätzlich mit Hilfe der Tabelle $A'$ prüfen, ob es auch
bei den Entfernungen nicht größer als 2 einen anderen Weg gibt, der mindestens der Länge 3 ist.
Tabelle $A'$ speichert die Länge der minimalen Entfernung von einer Batterie zu einer anderen,
die auch länger ist als 2. Abbildung \ref{fig:distances-aux} präsentiert ein Beispiel,
in dem diese besondere Unterscheidung wichtig ist.

\begin{figure}[h]
\centering
\begin{tabular}{c c}
\scalebox{1.5}{
\begin{tabular}{|c|c|}
\hline
5 &  \\
\hline
1 & \\
\hline
\end{tabular}}
& 
\scalebox{1.5}{
\begin{tabular}{|c|c|}
\hline
5 & 2 \\
\hline
1 & \\
\hline
\end{tabular}}
\end{tabular}
\caption{Dargestellt sind Fragmente einer Matrix. Die Zahlen stellen die Ladungen der Batterien dar, die auf diesen Feldern liegen.
\underline{Im ersten Beispiel} kann man vom Feld mit 5 das Feld mit 1 in minimaler Anzahl von einem Schritt erreichen.
Man kann auch aber dieses Feld in 3 Schritten erreichen, wenn man einen Schritt nach rechts, dann nach unten und nach links macht.
Außerdem kann man laut der Beobachtung \ref{observ:2k-steps} auch dieses Feld in 5 Schritten erreichen.
\underline{Im zweiten Beispiel} kann man nur das Feld mit 1 in einem Schritt erreichen, weil es keinen andren Weg vom Feld mit 5 
zum Feld mit 1 gibt, der länger ist als 2.}
\end{figure}\label{fig:distances-aux}

\subsubsection{Schleifen in Knoten}
Wir müssen auch einen Sonderfall berücksichtigen, dass man von einem Knoten zu demselben Knoten zurückkehren kann.
Mit Hilfe der Tabellen $A$ und $A'$ können wir es nicht überprüfen, ob es überhaupt möglich ist.\\
Um eine Schleife in Knoten $b$ durchzuführen, brauchen wir mindestens ein benachbartes Feld $i$, auf dem keine Batterie liegt.
Mit Hilfe dieses Feldes können wir einen Schritt von $b$ zu $i$ machen und von $i$ zu $b$ zurück.
Die Anzahl der Schritte ist $l = 2$.\\
Wenn wir aber sicherstellen, dass es neben einem batteriefreien Feld $i$ ein anderes batteriefreies Feld $j$ gibt ($i \neq j$),
können wir eine Schleife in $b$ erstellen, deren Länge $l=4$ ist. Auf folgender Weise machen wir die Schritte:
$b \rightarrow i \rightarrow j \rightarrow i \rightarrow b$. Auch hier können wir die in der Beobachtung \ref{observ:2k-steps}
bemerkte Ordnungsgemäßheit anwenden, wenn wir $l$ statt $A_{i,j}$ nehmen. (s. Abb. \ref{fig:extra-tiles}).
Wir legen noch ein Array $T$ fest, in dem wir die Information an der Stelle $T_i$ speichern, ob die Batterie $i$
zwei, eins oder null zusätliche, freie Nachbarfelder hat.\\

\begin{figure}[h]
\centering
\begin{tabular}{c c c}
\scalebox{1.5}{
\begin{tabular}{|c|c|c|}
\hline
1 & 4 & 1\\
\hline
1 &   & 1\\
\hline
2 & 5 & 1\\
\hline
\end{tabular}}
& 
\scalebox{1.5}{
\begin{tabular}{|c|c|c|}
\hline
1 & 4 & 1\\
\hline
1 &   & 1\\
\hline
1 &   & 1\\
\hline
2 & 5 & 1\\
\hline
\end{tabular}}
& 
\scalebox{1.5}{
\begin{tabular}{|c|c|c|}
\hline
1 & 4 & 1\\
\hline
1 & 2 & 1\\
\hline
2 & 5 & 1\\
\hline
\end{tabular}}
\end{tabular}
\caption{Dargestellt sind Fragmente einer Matrix. Die Zahlen stellen die Ladungen der Batterien dar, die auf diesen Feldern liegen.
\underline{Im ersten Beispiel} kann man maximal zwei Schritte von der Batterie mit der Ladung 4 machen, um an dieselbe Stelle zurückzukommen. \underline{Im zweiten Beispiel} kann man schon $2n$ Schitte machen, wobei $n \in \mathbb{N^{+}}$.
\underline{Im dritten Beispiel} kann man überhaupt keine Schleife durchführen.}
\end{figure}\label{fig:extra-tiles}

Auf diese Weise bekommen wir eine Tabelle $A$ mit allen minimalen Entfernungen zu Batterien, die von jeder Batterie
ereichbar sind. In der Tabelle $A'$ haben wir die zusätzlichen minimalen Entfernungen,
wenn der entsprechende Wert in $A$ kleiner ist als 3. Außerdem haben wir ein Array $T$, in dem die 
Anzahl der zusätlichen, batteriefreien Felder jeder Batterie gespeichert ist.

\subsection{Backtracking}
Unsere Aufgabe bleibt nun, so einen Pfad von der Startbatterie $s$ zu finden, der durch alle Batterien führt und am Ende alle Ladungen 0
betragen.
Außerdem muss man unbedingt den Aspekt beachten, dass man von einer Batterie zu einer anderen übergehen darf, nur wenn
die aktuelle Ladung nicht kleiner ist als die Entfernung zwischen den beiden.
Darüber hinaus wird die übriggebliebene Ladung mit der an der Stelle der Zielbatterie liegenden Ladung ausgetauscht.
Wir können auch sofort bemerken, dass es sich gar nicht lohnt, von einer Batterie zu einem Feld, auf dem keine Batterie
liegt, zu übergehen, weil wir einfach nicht fortsetzen könnten. Der Sonderfall ist hier natürlich die Situation am
Ende der Aufgabe, wenn alle Batterien besucht sind und alle liegenden Ladungen 0 betragen, aber wir mit der aktuellen Ladung übriggeblieben sind.
Dann müssen wir die aktuelle Ladung noch verbrauchen und es ergibt genauso viel Sinn zu einem batteriefreien sowie zu einem Feld mit einer Batterie
zu übergehen.\\
Wenn wir diese Situation ausschließen, können wir bermeken, dass wir stets von einer Batterie zu einer anderen übergehen müssen.\\
Wir können auch bemerken, dass dieses Problem sehr komplex ist. Schauen wir auf ein vereinfachtes Beispiel dieser Aufgabe.

\subsubsection{Klassifizierung des Problems}\label{sec:classification}
Angenommen, sind alle Werte in $A$ 1 und alle Batterien haben auch Ladungen 1 (wie im Beispiel \ref{example:1}).
Nun ist das Ziel der Aufgabe, einen Hamiltonpfad in diesem entstanden Graphen zu finden.
O.b.d.A. können wir annehmen, dass es sich um einen Hamiltonpfad und keinen Hamiltonzyklus handelt.
Wir starten üblicherweise von der Batterie mit Index 0 und gehen zu nächsten Batterien.
Wir müssen jedoch anmerken, dass wir bei der letzten Batterie
die Ladung zur nächsten Batterie nicht weiterleiten können, weil das schon das Ende der Matrix ist.
In diesem Falle können wir einfach die von der letzten Batterie zur vorletzten gehen.
Wir zählen dann auch nicht das vorletzte Feld als zweimal besucht.\\
Das Hamiltonkreisproblem ist ein NP--vollständiges Problem.
Wenn wir mehrere verschiedenen Ladungen und mehr Verbindungen unterschiedlicher Länge hinzufügen, 
wird das Problem komplexer. Daraux können wir schlussfolgern, dass es sich in unserem Problem
auch um NP--Vollständigkeit handelt.\\

Wir sollen auch bemerken, dass die Größe der Eingabe in den Beispielen sehr klein bleibt. Aus diesem entschied ich mih
für eine weniger effiziente, aber sehr genaue Methode, um diese Aufgabe zu lösen: Backtracking. 

Wir betrachten ein Array $C$, die die Ladungen jeder Batterie enthält. An jeder Stelle $i$ in diesem Array wird die aktuelle
Ladung einer Batterie mit dem Eingabeindex $i$ gespeichert.

\subsubsection{Erreichbarkeit}
Wir sollen zuerst definieren, was wir unter \textit{Erreichen} einer Batterie $c$ von einer $b$ aus verstehen.
Eine Batterie $c$ kann von einer Batterie $b$ aus erreicht werden, wenn die aktuelle Ladung nicht kleiner ist als die Entfernung 
an der Stelle $A_{b,c}$. Das bedeutet einfach, dass die Ladung ausreicht, um die Schritte von $b$ zu $c$ zu machen.
Außerdem soll $c$ in dem Array $C$ eine Ladung größer als 0 besitzen. So ist $c$ \textit{erreichbar}.\\
Ein Sonderfall in dieser Definition ist natürlich eine Schleife von $b$ zu sich selbst. 
In diesem Fall muss der Wert an der Stelle $b$ in der Matrix $T$ mindestens 1 betragen und die aktuelle Ladung muss
mindestens 2 sein.

\subsubsection{Rekursion}
Ich bildete eine rekursive Funktion, die alle möglichen Verbindungen zwischen jeweiligem Paar von Batterien untersucht.
Bei jedem Lauf der Funktion wird untersucht, zu welcher Batterie und mit wie vielen Schritten übergangen wird.\\
Wenn es möglich ist, von einer Batterie $a$ aus eine Batterie $b$ in $c$ Schitten zu erreichen, lässt man diese rekursive
Funktion dann an der Batterie $b$ laufen. Wenn es nicht geht, an einer Stelle fortzusetzten, wird abgebrochen
und man geht zürück zu der Batterie, an der noch eine Möglichkeit entsteht, von dieser Batterie einen anderen Weg zu nehmen
und mit einer anderen Anzahl von Schitten und/oder zu einer anderen Batterie zu übergehen. Wenn es zu einem Zustand kommt, dass alle
Batterien entladen sind, also alle Stellen in $C$ 0 betragen, wird dieser Stand als ein Ergebnis behandelt und ausgegeben.\\

Wir können die Funktionsweise dieser Funktion in Analogie zur Tiefensuche (engl. \textit{depth--first serach, DFS}) stellen.
In diesem Falle haben wir mit einem großen Baum mit einer Wurzel in $s$ zu tun.
Jede Kante in einem solchen Baum entspricht einer möglichen
Verbindung von einer Batterie zu einer anderen mit einer bestimmten Anzahl von Schritten.
Diese Anzahl an Schritten kann dementsprechend als ein Gewicht an einer Kanten gelten.
Die Blätter in einem solchen Baum sind natürlich Batterien, die von einer anderen Batterien an einem niedrigeren Niveau liegt.\\

\begin{figure}[h]
\begin{tikzpicture}[
level 1/.style={level distance=4cm, sibling distance=17mm},
level 2/.style={level distance=2cm, sibling distance=9mm}]
\tikzstyle{every node}=[circle,draw]
\node (s){$0^9$}
    child {node (a1) {$1^3$}
      child {node (a1c1) {$3^3$} edge from parent node[left,draw=none] {3}}
      child {node (a1a1) {$1^6$} edge from parent node[right,draw=none] {2}}
     edge from parent node[above,draw=none] {3}}
    child {node (a2) {$1^3$} 
      child {node (a2c1) {$3^3$} edge from parent node[left,draw=none] {3}}
      child {node (a2a2) {$1^4$} edge from parent node[right,draw=none] {2}} 
      edge from parent node[above,draw=none] {5}}
    child {node (a3) {$1^3$} 
      child {node (a3c1) {$3^3$} edge from parent node[left,draw=none] {3}}
      child {node (a3a3) {$1^2$} edge from parent node[right,draw=none] {2}}
    edge from parent node[above,draw=none] {7}}
    child {node (a4) {$1^3$} 
      child {node (a4c1) {$3^3$} edge from parent node[left,draw=none] {3}}
      child {node (a4a4) {$1^0$} edge from parent node[right,draw=none] {2}}
    edge from parent node[left,draw=none] {9}}
    child {node (b1) {$2^2$}
      child {node (b1b1) {$2^4$} edge from parent node[right,draw=none] {2}}
    edge from parent node[left,draw=none] {5}}
    child {node (b2) {$2^2$}
      child {node (b2b2) {$2^2$} edge from parent node[right,draw=none] {2}}
    edge from parent node[left,draw=none] {7}}
    child {node (b3) {$2^2$} 
      child {node (b3b3) {$2^0$} edge from parent node[right,draw=none] {2}}
    edge from parent node[below,draw=none] {9}}
    child {node (c1) {$3^3$} 
      child {node (c1a1) {$1^3$} edge from parent node[left,draw=none] {3}}
      child {node (c1c1) {$3^3$} edge from parent node[right,draw=none] {2}}
    edge from parent node[below,draw=none] {6}}
    child {node (c2) {$3^3$}
      child {node (c2c1) {$1^3$} edge from parent node[left,draw=none] {3}}
      child {node (c2c2) {$3^1$} edge from parent node[right,draw=none] {2}}
    edge from parent node[below,draw=none] {8}};
\end{tikzpicture}
\caption{Ein abgebildeter Baum der 0., 1. und 2. Niveaus des Beispiels \ref{example:0} (das Beispiel aus der Aufgabenstellung).
Die Nummern in Knoten entsprechen den Eingabeindizes der Batterien. Die Potenzen stellen die Ladung dar, die wir auf einem
Feld finden, wenn wir eine Batterie erreichen.}
\end{figure}

Diese rekursive Funktion nimmt als Parameter einen Eingabeindex $id$, die aktuelle Ladung, ein kopiertes Array $C$
und ein Array $R$, das die Information über einen aktuellen Pfad von der Batterie 0 zur Batterie $id$ speichert.
Das Array $R$ speichert die Eingabeindizes der Batterien, die bereits besucht wurden, mit der entsprechenden Anzahl von Schritten,
die gemacht wurden, um diese Zielbatterie zu erreichen.\\
Am Anfang der Funktion werden alle erreichbaren Batterien bestimmt. Ich forme dadruch ein Array $N_{id}$, das alle
erreichbaren Nachbarn von $id$, also die Eingabeindizes der Batterien, mit ihren entsprechenden minimalen Entfernungen enthält.
Bei der Bildung dieses Arrays stelle ich auch sicher, dass diese Batterien nach ihren verbliebenen Ladungen absteigend
sortiert sind.\\
Nun prüfe ich, ob $N_id$ leer ist. Das ist der terminierende Fall in meinem Algorithmus.
Wenn ja, prüfe ich, ob $T_{id} > 1$. Wenn die Batterie $id$ mindestens zwei batteriefreie Felder besitzt,
kann ich die restliche, aktuelle Ladung auf diesen beiden Feldern verbrauchen, indem wir einfach hin und her von einem 
Feld zum anderen übergehen. 
Dann erfolgt eine Prüfung, ob das Array $C$ an allen Stellen 0 enthält. Wenn ja, ist $R$ unser Ergebnis und der boolsche Wert 1 wird
ausgegeben. Andernfalls haben wir kein Ergebnis und der boolsche Wert 0 wird ausgegeben.\\
Wenn $N_{id}$ leer ich prüfe ich auch, ob $T_{id} = 1$. Wenn ja, können wir die ein restlicher Schritt verbrauchen, 
indem wir zu einem batteriefreien Feld übergehen. Danach prüfen wir, ob das Array $C$ an allen Stellen 0 enthält und die
aktuelle Ladung 0 beträgt. Wenn ja, ist unser Ergebnis ebenfalls $R$. Der boolsche Wert 1 wird ausgegeben. Andernfalls wird
der boolsche Wert 0 ausgegeben.\\
Anschließend, wenn $N_{id}$ leer ist und es keine adjazenten batteriefreien Felder gibt,  


Die erste aktuelle Ladung ist natürlich die Ladung der Batterie $s$, das heißt, der Startbatterie. An dieser Stelle
setzen wir im Array $C$ an der Stelle $0$ den Wert 0.\\
Wir lassen diese Funktion mit folgenden Parametern laufen: 0 als Eingabeindex, die aktuelle Ladung der Batterie $s$, 




\subsection{Laufzeit}\label{sec:time}

$b$ -- Anzahl der Batterien\\
$l$ -- Länge und Breite der Matrix $M$\\

Vorbereitung der Tabellen $A$ und $A'$:
\begin{itemize}
  \item Einlesen der Batterien: $O(b)$
  \item Bildung des Graphen: $O(l^2)$\\
  Zuordnung der Brettindizes und Esrstellung der Menge $E$: $O(l^2)$.
  \item Breitensuche: $O(b*l)$\\
  Die Laufzeit vom Breitensuchealgorithmus ist $O(V + E)$, $V = l$ und $E \leqslant 4*l$: $O(l+l)$.\\
  Der Algorithmus wird auf jeder Batterie angewendet: $O(b*l)$.
  \item Bestimmung der Schleifen in Knoten: $O(b)$\\
  Für jede Batterie werden die Schleifen in Knoten bestimmt, eine solche Bestimmu läuft in $O(1)$,
  also für alle Batterien: $O(b)$.
\end{itemize}


\subsection{Generierung von Spielsituationen}
\subsubsection{Idee}
\subsubsection{Laufzeit}


\subsection{Erweiterungen}



\newpage
\section{Umsetzung}
In meinem Programm wird eine Batterie als eine Klasse \texttt{Battery} dargestellt.
Jedes Objekt einer solchen Klasse besitzt jeweils eine $x$-- und $y$--Koordinate,
einen ganzzahligen Wert \texttt{charge}, der der Ladung einer Batterie entspricht;
einen Brettindex \texttt{boardID} und einen Eingabeindex \texttt{inputID}.\\

\subsection{Die Klasse \texttt{Graph}}
Wir erstellen zwei Matrizen: \texttt{distances} und \texttt{distancesAux}, die den Matrizen 
$A$ und $A'$ entsprechen. Sie sind jeweils auf folgender Weise erstellt: \texttt{vector< vector<int> >}.
Außerdem erstellen wir noch ein Array \texttt{extraTiles}, das dem Array $T$ entspricht.\\

In dieser Klasse wird die Textdatei eingelesen. Mit Hilfe der eingelesenen Größe der Matrix $M$\\ \texttt{boardDimension},
erstelle ich eine Matrix als \texttt{vector< vector<int> >}, die ich \texttt{board} nenne.
Beim Einlesen jeder Batterie werden ihr die eingelesenen Koordinaten, sowie die Ladung zugewiesen.
Danach werden jeder Batterie ihre Indizes zugeordnet. Als \texttt{inputID} gilt die
Reihenfolge, in der die Batterien in der Textdatei auftreten. Die Startbatterie $s$ bekommt einen
Eingabeindex von 0. Die restlichen Baterrien bekommen entsprechend die Indizes um 1 größer als ihre Vorgänger.
Für die Bestimmung des Brettindex einer Batterie $b$ bediene ich mich der folgender Formel:
\begin{align*}
\texttt{boardID}(b) = (b_y-1) * \texttt{boardDimension} + b_x-1
\end{align*}
Danach füge ich jeweilige Baterie in einen Map--Container \texttt{batteryToBoardID} mit ihrem entsprechenden Brettindex
und gleich danach in einen Map--Container \texttt{batteryToBoardID} ein. Im ersten dienen die Batterien als Schlüssel und werden
ihenen Brettindizes zugeordnet und im zweiten passiert das Gleiche aber andersherum: mit Brettindizes als Schlüsseln.\\
Danach erfolgt das Gleiche, wir fügen jeweilige Batterie in Map--Container \texttt{batteryToInputID} und
\texttt{inputIDToBattery} ein, diesmal mit ihren entsprechenden Eingabeindizes.\\

Es wird ein Array \texttt{nodes} in Form von \texttt{vector< vector< pair<int, int> > >}
erstellt, das die Nachbarn jedes Brettindex in der Matrix in Form von 
\texttt{pair}(Brettindex des Nachbarn, die Ladung des Nachbarn) enthält.\\
In der Methode \texttt{determineConnections()} wird die Matrix \texttt{board} iteriert.
Jedem Brettindex werden ihre Nachbarn im Array \texttt{neighbors} gespeichert.
Bei jeder Iteration werden die Brettindizes der Nachbarn anhand der obenstehenden Formel bestimmt.
Die Ladung an einer Stelle rufen wir aus der Matrix \texttt{board} ab. Wir speichern die beiden Informationen
im genannten Array. So durchlaufen wir alle Nachbarn jeder Stelle in der Matrix $M$.
Am Ende fügen wir das Array \texttt{neighbors} am Ende des Arrays \texttt{nodes}.\\

In der Methode \texttt{BFS(Battery b)} läuft natürlich der Breitensuche-Algorithmus.
Wir erstellen zwei lokale Arrays \texttt{battDistances} und \texttt{battDistancesAux} jeweils der Länge
der Anzahl aller Batterien. Außerdem erstellen wir ein Array \texttt{vis} mit \texttt{bool} der Größe
$\texttt{boardDimension}^2$, in dem wir die besuchten Knoten markieren.\\
Als \texttt{currInputID} speichern wir den Eingabeindex der Batterie \texttt{b}.
Wir formen eine Warteschlange \texttt{q}, die aus \texttt{pair <int, int>} besteht. Jedes solche Paar enthält
den Brettindex und Entfernung in Schritten von der Batterie \texttt{b}.\\
Wir fügen in \texttt{q} den Brettindex von \texttt{b} mit der Entfernung 0 ein. Wir markieren im Array \texttt{vis}
den entsprechenden Brettindex mit 1. Dann folgt die Iteration der Warteschlange, die so lange dauert, bis es
noch Elemente in \texttt{q} gibt.\\
Als \texttt{currBoardID} speichern wir den Brettindex, der sich am Anfang der Warteschlange befindet
und als \texttt{currDist} speichern wir die die Entfernung des Feldes \texttt{currBoardID} von \texttt{q}.
Sofort entfernen wir auch dieses erste Element aus der Warteschlange. Es folgt eine Iteration durch die Nachbarn
von \texttt{currBoardID} im Array \texttt{nodes}.\\
Als \texttt{neighBoardID} und \texttt{neighCharge} bezeichne ich entsprechend den Brettindex des iterierten
Nachbarn und die auf seinem Feld liegende Ladung. Es wird zuerst überprüft, ob \texttt{neighBoardID}
bereits besucht wurde. Wenn ja, wird der nächste Nachbar genommen.\\
Dann wird überprüft, ob \texttt{neighCharge} größer als 0 ist, das heißt, ob auf dem Feld \texttt{neighBoardID} eine 
Batterie liegt.\\
Wenn nicht, wird \texttt{neighBoardID} mit dem Wert \texttt{currDist} + 1 in \texttt{q} eingefügt.
Auch wird \texttt{neighBoardID} in \texttt{vis} mit 1 gekennzeichnet.\\
Wenn ja, wird die entsprechende Batterie anhand \texttt{neighBoardID} im Map--Container
\texttt{boardIDToBattery} gefunden. Die Laufzeit der Suchfunktion des Map--Containers wird im Abschnitt
\ref{sec:time} nicht betrachtet. Die gefundene Batterie nenne ich \texttt{neighborB}. 
Ihren Eingabeindex nenne ich \texttt{currNeighInputID}.
Nun wenn \texttt{battDistances} an der Stelle \texttt{currNeighInputID} gleich 2 oder 1 ist,
wird der Wert in \texttt{battDistancesAux} an der Stelle \texttt{currNeighInputID} aktualisiert, wenn
er größer ist als $\texttt{currDist} + 1$, oder wenn noch keinen solchen Wert gibt, wird als $\texttt{currDist} + 1$
gespeichert.\\
Andernaflls wird in \texttt{battDistances} an der Stelle \texttt{currNeighInputID} der Wert $\texttt{currDist} + 1$ gespeichert.
Nun nur wenn $\texttt{currDist} + 1$ größer ist als 2, wird \texttt{neighBoardID} als besucht in \texttt{vis} gekennzeichent.\\
Wenn es keine weiteren Brettindizes in der Warteschlange gibt, füge ich das Array \texttt{battDistances}
an der Stelle von \texttt{currInputID} in \texttt{distances} ein.
Das Gleiche erfolgt für das Array \texttt{battDistancesAux}. Es wird in \texttt{distancesAux} an der Stelle
\texttt{currInputID} gespeichert.\\

Die Methode \texttt{checkOneTile(Battery b)} prüft, ob es sich neben dem Feld, auf dem die Batterie \texttt{b}
liegt, ein betteriefreies Feld befindet.\\
Es wird das Array \texttt{nodes} an der Stelle, die dem Brettindex von \texttt{b} entspricht, iteriert.
Es wird überprüft, ob mindestens ein Nachbar von \texttt{b} eine Ladung von 0 besitzt, das heißt, auf
diesem Feld keine Batterie liegt. Es wird 1 ausgegeben, falls es ein Feld gibt, auf dem keine Batterie liegt.
Andernfalls wird 0 ausgegeben.\\

Die Methode \texttt{checkTwoTiles(Battery b)} prüft, ob sich neben dem Feld, auf dem die Batterie \texttt{b}
liegt, ein betteriefreies Feld befindet und dann überprüft, ob es noch ein batteriefreis Feld neben diesem
Feld gibt.\\
Diese Funkiton funktioniert auf ähnlicher Weise wie die Methode \texttt{checkOneTile}.
Nun iterieren wir noch durch das Array von Nachbarn vom batteriefreien Nachbarn von \texttt{b} in \texttt{nodes}.
Wenn es ein solches betteriefreie Feld gibt, wird 1 ausgegeben. Andernfalls wird 0 ausgegeben.\\

Im Konstruktor dieser Klasse lassen wir die Methoden \texttt{readFile} und dann \texttt{determineConnections}
laufen. Danach für jede Batterie lassen wir die Methode \texttt{BFS} laufen.
Gleich danach wenden wir die Methode \texttt{checkOneTile} an jeweiliger Batterie an und wenn
1 ausgegeben wird, schreiben wir 1 an der Stelle des Eingabeindex dieser Batterie in \texttt{extraTiles}.
Danach wenden wir die Methode \texttt{checkTwoTiles} an jeweiliger Batterie an und wenn
1 ausgegeben wird, schreiben wir 2 an der Stelle des Eingabeindex dieser Batterie in \texttt{extraTiles}.\\
So bekommen wir eine Tabelle \texttt{distances} mit allen minimalen Entfernungen von
jeder Batterie zu allen anderen. Die Entfernungen zu den Batterien, die nicht erreicht werden können, betragen 0.
Außer diesen Batterien besitzt nur die Batterie, von der wir die Entfernungen messen, den Wert 0.
Für Schleifen haben wir ja auch das Array \texttt{extraTiles}. Das bedeutet, dass wir in weiteren Betrachtungen
die Stellen, an denen 0 steht, überhaupt nicht betrachten müssen.

\subsection{Die Klasse \texttt{Backtracking}}

\subsection{Die Klasse \texttt{Generator}}

\newpage
\section{Beispiele}
Die untenstehenden Zahlen, die die Folgen der Schitten bei einer Spielsituation darstellen, stehen für die Eingabeindizes
der Batterien in einer Spielsituation. Diese Indizes entsprechen der Reihenfolge der Batterien in der Textdatei. Man fängt mit 0 an,
diese Zahl entspricht der Startbatterie.\\
Eine Notation $a(d_a) \rightarrow b(d_b)$ bedeutet, dass man von der Batterie mit dem Eingabeindex $a$ zur Betterie $b$ genau $d_b$ Schritten
gemacht hat. Das heißt, dass man von der Ladung von $a$ $d_b$ abgezogen hat und die übrige Ladung auf das Feld mit $b$ gestellt hat.\\
Zahl $-1$ steht für ein beliebiges Feld, zu dem man am Ende übergeht, um die restliche Ladung aus der letzten Batterie auszunutzen.

\subsection{Beispiel 0 (BWINF)}\label{example:0}
Textdatei: \texttt{stromrallye0.txt}\\

\noindent
\fbox{Die Spielsituation ist lösbar.}\\

\noindent
Zeit: 0 min 0 s\\

\noindent
$0 \rightarrow3(3) \rightarrow 1(3) \rightarrow 3(3) \rightarrow 2(6) \rightarrow 2(2)$

\subsection{Beispiel 1 (BWINF)}\label{example:1}
Textdatei: \texttt{stromrallye1.txt}\\

\noindent
\fbox{Die Spielsituation ist lösbar.}\\

\noindent
Zeit: 0 min 0 s\\

\noindent
$0 \rightarrow1(1) \rightarrow 2(1) \rightarrow 3(1) \rightarrow 4(1) \rightarrow 5(1) \rightarrow 6(1) \rightarrow 7(1) \rightarrow 8(1) 
\rightarrow 9(1) \rightarrow 19(1) \rightarrow 18(1) \rightarrow 17(1) \rightarrow 16(1) \rightarrow 15(1) \rightarrow 14(1) \rightarrow 13(1) 
\rightarrow 12(1) \rightarrow 11(1) \rightarrow 10(1) \rightarrow 20(1) \rightarrow 21(1) \rightarrow 22(1) \rightarrow 23(1) \rightarrow 24(1) 
\rightarrow 25(1) \rightarrow 26(1) \rightarrow 27(1) \rightarrow 28(1) \rightarrow 29(1) \rightarrow 39(1) \rightarrow 38(1) \rightarrow 37(1) 
\rightarrow 36(1) \rightarrow 35(1) \rightarrow 34(1) \rightarrow 33(1) \rightarrow 32(1) \rightarrow 31(1) \rightarrow 30(1) \rightarrow 40(1) 
\rightarrow 41(1) \rightarrow 42(1) \rightarrow 43(1) \rightarrow 44(1) \rightarrow 45(1) \rightarrow 46(1) \rightarrow 47(1) \rightarrow 48(1) 
\rightarrow 49(1) \rightarrow 59(1) \rightarrow 58(1) \rightarrow 57(1) \rightarrow 56(1) \rightarrow 55(1) \rightarrow 54(1) \rightarrow 53(1) 
\rightarrow 52(1) \rightarrow 51(1) \rightarrow 50(1) \rightarrow 60(1) \rightarrow 61(1) \rightarrow 62(1) \rightarrow 63(1) \rightarrow 64(1) 
\rightarrow 65(1) \rightarrow 66(1) \rightarrow 67(1) \rightarrow 68(1) \rightarrow 69(1) \rightarrow 79(1) \rightarrow 78(1) \rightarrow 77(1) 
\rightarrow 76(1) \rightarrow 75(1) \rightarrow 74(1) \rightarrow 73(1) \rightarrow 72(1) \rightarrow 71(1) \rightarrow 70(1) \rightarrow 80(1) 
\rightarrow 81(1) \rightarrow 82(1) \rightarrow 83(1) \rightarrow 84(1) \rightarrow 85(1) \rightarrow 86(1) \rightarrow 87(1) \rightarrow 88(1) 
\rightarrow 89(1) \rightarrow 99(1) \rightarrow 98(1) \rightarrow 97(1) \rightarrow 96(1) \rightarrow 95(1) \rightarrow 94(1) \rightarrow 93(1) 
\rightarrow 92(1) \rightarrow 91(1) \rightarrow 90(1) \rightarrow 80(1) \rightarrow 91(1) 
$

\subsection{Beispiel 2 (BWINF)}\label{example:2}
Textdatei: \texttt{stromrallye2.txt}\\

\noindent
\fbox{Die Spielsituation ist lösbar.}\\

\noindent
Zeit: 0 min 0 s\\

\noindent
$0 \rightarrow 50(1) \rightarrow 39(1) \rightarrow 28(1) \rightarrow 17(1) \rightarrow 6(1) \rightarrow 5(1) \rightarrow 4(1) \rightarrow 3(1) 
\rightarrow 2(1) \rightarrow 1(1) \rightarrow 12(1) \rightarrow 13(1) \rightarrow 14(1) \rightarrow 15(1) \rightarrow 16(1) \rightarrow 27(1) 
\rightarrow 26(1) \rightarrow 25(1) \rightarrow 24(1) \rightarrow 23(1) \rightarrow 34(1) \rightarrow 35(1) \rightarrow 36(1) \rightarrow 37(1) 
\rightarrow 38(1) \rightarrow 49(1) \rightarrow 48(1) \rightarrow 47(1) \rightarrow 46(1) \rightarrow 45(1) \rightarrow 56(1) \rightarrow 57(1) 
\rightarrow 58(1) \rightarrow 59(1) \rightarrow 60(1) \rightarrow 70(1) \rightarrow 69(1) \rightarrow 68(1) \rightarrow 67(1) \rightarrow 66(1) 
\rightarrow 77(1) \rightarrow 78(1) \rightarrow 79(1) \rightarrow 80(1) \rightarrow 81(1) \rightarrow 82(1) \rightarrow 71(1) \rightarrow 72(1) 
\rightarrow 61(1) \rightarrow 51(1) \rightarrow 40(1) \rightarrow 29(1) \rightarrow 18(1) \rightarrow 7(1) \rightarrow 8(1) \rightarrow 9(1) 
\rightarrow 10(1) \rightarrow 11(1) \rightarrow 22(1) \rightarrow 21(1) \rightarrow 20(1) \rightarrow 19(1) \rightarrow 30(1) \rightarrow 31(1) 
\rightarrow 32(1) \rightarrow 33(1) \rightarrow 44(1) \rightarrow 43(1) \rightarrow 42(1) \rightarrow 41(1) \rightarrow 52(1) \rightarrow 53(1) 
\rightarrow 54(1) \rightarrow 55(1) \rightarrow 65(1) \rightarrow 64(1) \rightarrow 63(1) \rightarrow 62(1) \rightarrow 73(1) \rightarrow 74(1) 
\rightarrow 75(1) \rightarrow 76(1) \rightarrow 87(1) \rightarrow 86(1) \rightarrow 85(1) \rightarrow 84(1) \rightarrow 83(1) \rightarrow 94(1) 
\rightarrow 93(1) \rightarrow 92(1) \rightarrow 91(1) \rightarrow 90(1) \rightarrow 89(1) \rightarrow 88(1) \rightarrow 99(1) \rightarrow 100(1) 
\rightarrow 101(1) \rightarrow 102(1) \rightarrow 103(1) \rightarrow 104(1) \rightarrow 105(1) \rightarrow 106(1) \rightarrow 95(1) 
\rightarrow 96(1) \rightarrow 97(1) \rightarrow 98(1) \rightarrow 109(1) \rightarrow 108(1) \rightarrow 107(1) \rightarrow 118(1) 
\rightarrow 117(1) \rightarrow 116(1) \rightarrow 115(1) \rightarrow 114(1) \rightarrow 113(1) \rightarrow 112(1) \rightarrow 111(1) 
\rightarrow 110(1) \rightarrow 99(1) \rightarrow 88(1) \rightarrow 77(1) \rightarrow 66(1) \rightarrow 56(1) \rightarrow 45(1) \rightarrow 34(1) 
\rightarrow 23(1) \rightarrow 12(1) \rightarrow 1(1) \rightarrow 2(1) \rightarrow 3(1) \rightarrow 4(1) \rightarrow 5(1) \rightarrow 6(1) 
\rightarrow 7(1) \rightarrow 8(1) \rightarrow 9(1) \rightarrow 10(1) \rightarrow 11(1) \rightarrow 22(1) \rightarrow 21(1) \rightarrow 20(1) 
\rightarrow 19(1) \rightarrow 18(1) \rightarrow 17(1) \rightarrow 16(1) \rightarrow 15(1) \rightarrow 14(1) \rightarrow 13(1) \rightarrow 24(1) 
\rightarrow 25(1) \rightarrow 26(1) \rightarrow 27(1) \rightarrow 28(1) \rightarrow 29(1) \rightarrow 30(1) \rightarrow 31(1) \rightarrow 32(1) 
\rightarrow 33(1) \rightarrow 44(1) \rightarrow 43(1) \rightarrow 42(1) \rightarrow 41(1) \rightarrow 40(1) \rightarrow 39(1) \rightarrow 38(1) 
\rightarrow 37(1) \rightarrow 36(1) \rightarrow 35(1) \rightarrow 46(1) \rightarrow 47(1) \rightarrow 48(1) \rightarrow 49(1) \rightarrow 50(1) 
\rightarrow 51(1) \rightarrow 52(1) \rightarrow 53(1) \rightarrow 54(1) \rightarrow 55(1) \rightarrow 65(1) \rightarrow 64(1) \rightarrow 63(1) 
\rightarrow 62(1) \rightarrow 61(1) \rightarrow 72(1) \rightarrow 71(1) \rightarrow 70(1) \rightarrow 60(1) \rightarrow 59(1) \rightarrow 58(1) 
\rightarrow 57(1) \rightarrow 67(1) \rightarrow 68(1) \rightarrow 69(1) \rightarrow 80(1) \rightarrow 79(1) \rightarrow 78(1) \rightarrow 89(1) 
\rightarrow 90(1) \rightarrow 91(1) \rightarrow 92(1) \rightarrow 81(1) \rightarrow 82(1) \rightarrow 83(1) \rightarrow 84(1) \rightarrow 73(1) 
\rightarrow 74(1) \rightarrow 75(1) \rightarrow 76(1) \rightarrow 87(1) \rightarrow 86(1) \rightarrow 85(1) \rightarrow 96(1) \rightarrow 95(1) 
\rightarrow 94(1) \rightarrow 93(1) \rightarrow 104(1) \rightarrow 103(1) \rightarrow 102(1) \rightarrow 101(1) \rightarrow 100(1) 
\rightarrow 99(1) \rightarrow 110(1) \rightarrow 111(1) \rightarrow 112(1) \rightarrow 113(1) \rightarrow 114(1) \rightarrow 115(1) 
\rightarrow 116(1) \rightarrow 105(1) \rightarrow 106(1) \rightarrow 107(1) \rightarrow 108(1) \rightarrow 97(1) \rightarrow 98(1) 
\rightarrow 109(1) \rightarrow 120(1) \rightarrow 119(1) \rightarrow 118(1) \rightarrow 117(1) \rightarrow 118(1) \rightarrow 119(1) 
\rightarrow 108(1) \rightarrow 118(1) \rightarrow 120(1) 
$

\subsection{Beispiel 3 (BWINF)}\label{example:3}
Textdatei: \texttt{stromrallye3.txt}\\

\noindent
\fbox{Die Spielsituation ist nicht lösbar.}\\

\noindent
Zeit: 0 min 0 s

\subsection{Beispiel 4 (BWINF)}\label{example:4}
Textdatei: \texttt{stromrallye4.txt}\\

\noindent
\fbox{Die Spielsituation ist lösbar.}\\

\noindent
Zeit: 0 min 0 s\\

\noindent
$0 \rightarrow -1(20)$

\subsection{Beispiel 5 (BWINF)}\label{example:5}
Textdatei: \texttt{stromrallye5.txt}\\

\noindent
\fbox{Die Spielsituation ist nicht lösbar.}\\

\noindent
Zeit: 16 min 59 s

\subsection{Beispiel 6}\label{example:6}
Textdatei: \texttt{stromrallye6.txt}\\
Besonderheit: eine Kopie des Beipsiels \ref{example:3}, aber die Batterie auf dem Feld (6, 2) besitzt eine Ladung von 4\\

\noindent
\fbox{Die Spielsituation ist lösbar.}\\

\noindent
Zeit: 0 min 0 s\\

\noindent
$0 \rightarrow2(9) \rightarrow 1(9) \rightarrow 3(2) \rightarrow 3(2) \rightarrow 3(2) \rightarrow 1(2) \rightarrow -1(1)$

\noindent
\subsection{Beispiel 7}\label{example:7}
Textdatei: \texttt{stromrallye7.txt}\\
Besonderheit: eine Kopie des Beipsiels \ref{example:5} mit einer zusätzlichen Batterie auf dem Feld (2, 16) mit einer Ladung von 1\\

\noindent
\fbox{Die Spielsituation ist lösbar.}\\

\noindent
Zeit: 9 min 16 s\\

\noindent
$0 \rightarrow 1(4) \rightarrow 3(7) \rightarrow 4(2) \rightarrow 3(10) \rightarrow 2(3) \rightarrow 1(4) \rightarrow 5(6) \rightarrow 5(2) 
\rightarrow 12(10) \rightarrow 6(3) \rightarrow 6(2) \rightarrow 7(2) \rightarrow 8(2) \rightarrow 9(2) \rightarrow 10(2) \rightarrow 11(2) 
\rightarrow 13(1) \rightarrow 14(1) \rightarrow 15(1) \rightarrow 16(1) \rightarrow 17(1) \rightarrow 18(1) \rightarrow 19(1) \rightarrow 20(3) 
\rightarrow 21(1) \rightarrow 22(1) \rightarrow 23(1) \rightarrow 24(1) \rightarrow 25(1) \rightarrow 28(1) \rightarrow 27(1) \rightarrow 26(1) 
\rightarrow 27(1) \rightarrow 30(1) \rightarrow 31(1) \rightarrow 30(1) \rightarrow 33(1) \rightarrow 34(1) \rightarrow 35(1) \rightarrow 32(1) 
\rightarrow 29(1) \rightarrow -1(1) $

\subsection{Beispiel 8}\label{example:8}
Textdatei: \texttt{stromrallye8.txt}\\
Besonderheit: ein anhand des selbst gebauten Generators generiertes Beispiel\\

\noindent
\fbox{Die Spielsituation ist lösbar.}\\

\noindent
Zeit: 0 min 0 s\\

\noindent
$0 \rightarrow3(2) \rightarrow 1(3) \rightarrow 1(2) \rightarrow 2(3) \rightarrow 4(6) \rightarrow 5(4) \rightarrow 5(2) \rightarrow 5(2)
\rightarrow 5(2) \rightarrow 5(2) \rightarrow 5(2) \rightarrow 5(2) \rightarrow 5(2) \rightarrow 5(2)$


\newpage
\section{Quellcode}
\lstinputlisting[language=C++]{stromrallye.m}

\end{document}